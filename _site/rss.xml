<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Welcome to</title>
        <description>Welcome to - Jian Wang</description>
        <link>http://jianwang.info/</link>
        <link>http://jianwang.info/</link>
        <lastBuildDate>2016-03-17T12:55:21-07:00</lastBuildDate>
        <pubDate>2016-03-17T12:55:21-07:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Assembly on Mac</title>
                <description>&lt;p&gt;Assembly language is the very basic programming language in a Computer. First it is more detailed. Second it is more effcient. Today I am going to try it on my macbook. Although it is not my first time to try assembly, I feel more comfortable and engaged to do so. This airticle will record some of method and tools.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;tool&quot;&gt;Tool&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;NASM&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew install nasm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Xcode
which contains gcc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;this link is a very good materail to learn 64 bit assembly on mac
http://www.idryman.org/blog/2014/12/02/writing-64-bit-assembly-on-mac-os-x/&lt;/p&gt;

&lt;p&gt;here is a short example&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_asm.s
# as hello_asm.s -o hello_asm.o
# ld hello_asm.o -e _main -o hello_asm
.section __DATA,__data
str:
  .asciz &quot;Hello world!\n&quot;

.section __TEXT,__text
.globl _main
_main:
  movl $0x2000004, %eax           # preparing system call 4
  movl $1, %edi                    # STDOUT file descriptor is 1
  movq str@GOTPCREL(%rip), %rsi   # The value to print
  movq $100, %rdx                 # the size of the value to print
  syscall

  movl $0, %ebx
  movl $0x2000001, %eax           # exit 0
  syscall

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I have already installed gcc on my computer, so I will not install nasm.&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//learn/2016/03/17/Assembly-Study</link>
                <guid>http://jianwang.info//learn/2016/03/17/Assembly-Study</guid>
                <pubDate>2016-03-17T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Facebook Technology Study I</title>
                <description>&lt;p&gt;As is known to us all, Facebook is world class big tech company which is engaging in connecting the world with its various open source software and open source hardware. So far Facebook has had 296 open source projects on GitHub with 10+ Million Lines of code, 265k Followers and 43k Forks. This airticle is going to introduce the general open source software infrastructure of Facebook. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Open source is very important for Facebook. Being open is better than being close. Being connection is better than being isolation. Bellow is a short list of facebook’s open source software in the last 6 months.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grocery-delivery
ig-json-parser
xhp-bootstrap
parseapplinksanalytics
fbcuda
mcrouter
errgroup
third-party
fb-adb
flow
css-layout
httpdown
riftdk1
jsx
vim-flow
flux
dfuse
thpp
immutable-js
fblualib
rpool
osquery
fatal
ds2
proxygen : layer 7 load balancer
fbpca
stats
rebound-js
runcmd
asyncdisplaykit
neti
fbcunn
f8developerconferenceapp
parse-facebook-user-session
parseui-ios
parse-php-sdk
facebook-python-ads-sdk
oss-performance
taste-tester
presto-odbc
between-meals
neti-cookbook
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Facebook mainly focus on 4 main softwares: data infrastructure like “Presto” and “rocksdb”, server runtime like “proxygen” and “HHVM”, web framework like “javascript”, mobile tools and libraries.&lt;/p&gt;

&lt;p&gt;RocksDB is an embeddable persistent key-value store for fast storage. RocksDB can also be the foundation for a client-server database but our current focus is on embedded workloads.&lt;/p&gt;

&lt;p&gt;Presto is an open source distributed SQL query engine for running interactive analytic queries against data sources of all sizes ranging from gigabytes to petabytes.&lt;/p&gt;

&lt;p&gt;Why open source is very important?&lt;/p&gt;

&lt;p&gt;In the year 2004, facebook start with LAMP frame (Linux, Apache, Mysql, PHP),  now it’s like a giant LAMP website with third degree scale. Engineers has done a lot to improve the LAMP and memcache.  you had to make it scale. For example, first we use Mysql, then we need to scale it, then need improve it, even replace it. After we release it, we continue using it, it become a loop.&lt;/p&gt;

&lt;p&gt;How facebook contribute?&lt;/p&gt;

&lt;p&gt;Hardware: Facebook open a hardware project called “open compute project”, you can buy those hardware from OEM, they don’t have secret anymore.&lt;/p&gt;

&lt;p&gt;OCP data center design: mechanical design, electronical design.&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//technology/2016/02/23/Facebook-Study-I</link>
                <guid>http://jianwang.info//technology/2016/02/23/Facebook-Study-I</guid>
                <pubDate>2016-02-23T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Ugly Number II</title>
                <description>&lt;p&gt;Problem 264 Ugly Number II&lt;/p&gt;

&lt;p&gt;Write a program to find the n-th ugly number.&lt;/p&gt;

&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.&lt;/p&gt;

&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;

&lt;p&gt;Hint: The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;n = 10 return 12&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;C++&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;analysis&quot;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;解法1: Brute Force： 此暴力破解还稍微带点动态规划的意味在里面。 思路是利用它的一个规律。 打个比喻：即从最小的丑数开始，“1， 2，3，4，5…”，你会发现如果把前面这串数字当成一个保龄球轨道的话，那么“2，3，5”这个就是一个滚动的保龄球，从头开始滚动，保龄球与轨道接触的那一面的数字相乘的结果（去重复后）往轨道最后放。相切的点就是的结果。但是这样的方法有很多明显的缺陷，为了去重要多花费2n的空间（6&lt;em&gt;3等于9&lt;/em&gt;2重复） ，而且实际执行的次数要多于n。&lt;/p&gt;

&lt;p&gt;解法2: 三指针： 与以上解法相比，此解法发现了真正的pattern。还拿以上例子来讲，就是把保龄球换成蜗牛，三个蜗牛（数字分别是2，3，5）起初都在起跑线上，谁与轨道的乘积最小谁就往前爬一步，这样当出现重复数字的时候，都会在同一个循环里，（即3&lt;em&gt;6与2&lt;/em&gt;9两个最小值在同时出现，那么两者都往前爬一步），这样就省了去重复的多余空间和操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时间：O(n)&lt;/p&gt;

&lt;p&gt;空间：O(n)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现一(cpp)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
long long nthUglyNumber1(int n) {
 if (n == 0) return 0;
 unordered_set&amp;lt;long long&amp;gt; set1;
 vector&amp;lt;int&amp;gt; ugly = {2,3,5};
 priority_queue&amp;lt;long long&amp;gt; queue1;
 for (int i = 1; i &amp;lt; 6; i++ ) {
   queue1.push(-i);
   set1.emplace(i);
 }
 long long result;
 for (int i = 0; i &amp;lt; k; i++) {
   result = -queue1.top();
   queue1.pop();
   for (int j = 0; j &amp;lt; 3; j++) {
     if (set1.find(ugly[j]*result) == set1.end()) {
       queue1.push(-ugly[j]*result);
       set1.emplace(ugly[j]*result);
     }
   }
 }
 return result;   }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时间：O(n)&lt;/p&gt;

&lt;p&gt;空间：O(n)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现二(cpp)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
int nthUglyNumber(int n) {    
    vector&amp;lt;int&amp;gt; result(1, 1);
    int i2 = 0, i3 = 0, i5 = 0;
    while (result.size() &amp;lt; n) {
        int m2 = result[i2] * 2, 
            m3 = result[i3] * 3, 
            m5 = result[i5] * 5;
        int mn = min(m2, min(m3, m5));
        if (mn == m2) ++i2;
        if (mn == m3) ++i3;
        if (mn == m5) ++i5;
        result.push_back(mn);
    }
    return result.back();
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;596 / 596 test cases passed.&lt;/li&gt;
  &lt;li&gt;Status: Accepted&lt;/li&gt;
  &lt;li&gt;Runtime: 20 ms&lt;/li&gt;
  &lt;li&gt;Beats: 48.17%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;实现三(cpp)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
public int nthUglyNumber(int n) {
    int[] ugly = new int[n];
    int v2 = 1, v3 = 1, v5 = 1;
    int i2 = 0, i3 = 0, i5 = 0;
    for (int k = 0; k &amp;lt; n; ++k) {
        int v = Math.min(v2, Math.min(v3, v5));
        ugly[k] = v;
        if (v2 == v) v2 = ugly[i2++] * 2;
        if (v3 == v) v3 = ugly[i3++] * 3;
        if (v5 == v) v5 = ugly[i5++] * 5;
    }
    return ugly[n-1];
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;596 / 596 test cases passed.&lt;/li&gt;
  &lt;li&gt;Status: Accepted&lt;/li&gt;
  &lt;li&gt;Runtime: 8 ms&lt;/li&gt;
  &lt;li&gt;Beats: 90.84%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;实现四(Java)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
public int nthUglyNumber(int n) {
    int[] ugly = new int[n];
    int v2 = 1, v3 = 1, v5 = 1;
    int i2 = 0, i3 = 0, i5 = 0;
    for (int k = 0; k &amp;lt; n; ++k) {
        int v = Math.min(v2, Math.min(v3, v5));
        ugly[k] = v;
        if (v2 == v) v2 = ugly[i2++] * 2;
        if (v3 == v) v3 = ugly[i3++] * 3;
        if (v5 == v) v5 = ugly[i5++] * 5;
    }
    return ugly[n-1];
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;596 / 596 test cases passed.&lt;/li&gt;
  &lt;li&gt;Status: Accepted&lt;/li&gt;
  &lt;li&gt;Runtime: 8 ms&lt;/li&gt;
  &lt;li&gt;Beats: 85.65%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;实现五(Python)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def nthUglyNumber(self, n):
ugly = [1] * n
i2 = i3 = i5 = -1
x = v2 = v3 = v5 = 1
for k in xrange(n):
    x = min(v2, v3, v5)
    ugly[k] = x
    if x == v2:
        i2 += 1
        v2 = ugly[i2] * 2
    if x == v3:
        i3 += 1
        v3 = ugly[i3] * 3
    if x == v5:
        i5 += 1
        v5 = ugly[i5] * 5
return x
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;596 / 596 test cases passed.&lt;/li&gt;
  &lt;li&gt;Status: Accepted&lt;/li&gt;
  &lt;li&gt;Runtime: 176 ms&lt;/li&gt;
  &lt;li&gt;94.23%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Contribution&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jianwang.info/&quot;&gt;@jianw851&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[^1] &lt;a href=&quot;https://leetcode.com/problems/ugly-number-ii/&quot;&gt;264. Ugly Number II &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[^2] &lt;a href=&quot;http://www.cnblogs.com/grandyang/p/4743837.html&quot;&gt;博客园Grandyang&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/02/15/Ugly-Number_II</link>
                <guid>http://jianwang.info//algorithm/2016/02/15/Ugly-Number_II</guid>
                <pubDate>2016-02-15T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Clone Graph</title>
                <description>&lt;p&gt;Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.&lt;/p&gt;

&lt;p&gt;How we serialize an undirected graph:&lt;/p&gt;

&lt;p&gt;Nodes are labeled uniquely.&lt;/p&gt;

&lt;p&gt;We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.&lt;/p&gt;

&lt;p&gt;The graph has a total of three nodes, and therefore contains three parts as separated by #.&lt;/p&gt;

&lt;p&gt;First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.&lt;/p&gt;

&lt;p&gt;return a deep copied graph.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
  if (node == NULL) return NULL;
  unordered_map&amp;lt;UndirectedGraphNode*, UndirectedGraphNode*&amp;gt; map1;
  vector&amp;lt;UndirectedGraphNode*&amp;gt; queue;
  queue.push_back(node);
  UndirectedGraphNode *head = new UndirectedGraphNode(node-&amp;gt;label);
  map1[node] = head;
  int curr = 0;
  while (curr &amp;lt; queue.size()) {
    UndirectedGraphNode * curr_node = queue[curr];
    int size = curr_node-&amp;gt;neighbors.size();
    for (int i = 0; i &amp;lt; size; i++) {
      UndirectedGraphNode * curr_neigh = curr_node-&amp;gt;neighbors[i];
      if (map1.find(curr_neigh) == map1.end()) {
        UndirectedGraphNode * curr_copy = new UndirectedGraphNode(curr_neigh-&amp;gt;label);
        map1[curr_node]-&amp;gt;neighbors.push_back(curr_copy);
        map1[curr_neigh] = curr_copy;
        queue.push_back(curr_neigh);
      } else {
        map1[curr_node]-&amp;gt;neighbors.push_back(map1[curr_neigh]);
      }
    }
    curr++;
  }
  return head;
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Contribution&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jianwang.info/&quot;&gt;@jianw851&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/02/03/Clone-Graph</link>
                <guid>http://jianwang.info//algorithm/2016/02/03/Clone-Graph</guid>
                <pubDate>2016-02-03T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Missing Number</title>
                <description>&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;Given nums = [0, 1, 3] return 2&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;复杂度&lt;/p&gt;

&lt;p&gt;时间：O(n)&lt;/p&gt;

&lt;p&gt;空间：O(1)&lt;/p&gt;

&lt;p&gt;实现一(cpp)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:    int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
  if (nums.size() == 0) return 0;
  int sum = 0;
  int n = nums.size();
  for (int i = 0; i &amp;lt; nums.size(); i++) {
    sum += nums[i];
  }
  return (n+1)*n/2 - sum;
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度&lt;/p&gt;

&lt;p&gt;时间：O(n)&lt;/p&gt;

&lt;p&gt;空间：O(0)&lt;/p&gt;

&lt;p&gt;实现二(cpp)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
  if (nums.size() == 0) return 0;
  int result = 0;
  for (int i = 0; i &amp;lt; nums.size(); i++) {
     result ^= (i+1) ^ nums[i];
  }
  return result;
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复杂度&lt;/p&gt;

&lt;p&gt;时间：O(n)&lt;/p&gt;

&lt;p&gt;空间：O(n)&lt;/p&gt;

&lt;p&gt;实现三(cpp)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:    int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
  if (nums.size() == 0) return 0;
  vector&amp;lt;bool&amp;gt; list(nums.size(), true);
  for (int i = 0; i &amp;lt; nums.size(); i++) {
    list[nums[i]] = false;
  }
  int i = 0;
  for (; i &amp;lt; list.size(); i++) {
    if (list[i]) return i;
  }
  return i;
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Contribution&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jianwang.info/&quot;&gt;@jianw851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Reference&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/&quot;&gt;268. Missing Number&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/02/01/Missing-Number</link>
                <guid>http://jianwang.info//algorithm/2016/02/01/Missing-Number</guid>
                <pubDate>2016-02-01T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Power Of Two</title>
                <description>&lt;!--more--&gt;

&lt;p&gt;Problem 231 Power of Two
 Given an integer, write a function to determine if it is a power of two.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;n = 12&lt;/p&gt;

&lt;p&gt;return false&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;n = 64&lt;/p&gt;

&lt;p&gt;return true&lt;/p&gt;

&lt;p&gt;解法1: 数学法， 2的幂不管怎样二分，都能被2整除，直到变为1.&lt;/p&gt;

&lt;p&gt;解法2: 位操作， 2的幂在二进制表示的时候，有一个特性，那就是只有一个1在里面（如：00001000就是2的幂，
而00001100就不是2的幂），利用这个特性我们就可以衍生出三种解法都可以达到用O(1)的时间复杂度.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;移位法：把后面的0移掉，剩下的部分＝＝1，就对了 (不推荐)&lt;/li&gt;
  &lt;li&gt;－1求与：n &amp;amp; n-1 == 0 就对了 （推荐）&lt;/li&gt;
  &lt;li&gt;补数求与： (n &amp;amp; (~n + 1)) == n 就对了 （尚可）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;网上对这道题的分析太透彻，其他的解法我就不再赘述，把链接贴在reference大家自己看。我就把两种解法写出来。&lt;/p&gt;

&lt;p&gt;复杂度&lt;/p&gt;

&lt;p&gt;时间：O(1)&lt;/p&gt;

&lt;p&gt;空间：O(0)&lt;/p&gt;

&lt;p&gt;实现一(cpp)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
bool isPowerOfTwo(int n) {
  return n &amp;gt; 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0);
}
}; 复杂度
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;时间：O(logn)&lt;/p&gt;

&lt;p&gt;空间：O(1)
实现二(cpp)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
bool isPowerOfTwo(int n) {
  if (n &amp;lt;= 0) return false;
  while (n != 1) {
    if (n % 2 != 0)
    return false;
    n /= 2;
  }
  return true;
}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Contribution&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jianwang.info/&quot;&gt;@jianw851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Reference&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/power-of-two/&quot;&gt;231. Power of Two&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.exploringbinary.com/ten-ways-to-check-if-an-integer-is-a-power-of-two-in-c/&quot;&gt;Ten Ways to Check if an Integer Is a Power Of Two in C&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://jianwang.info//algorithm/2016/01/30/Power-Of-Two</link>
                <guid>http://jianwang.info//algorithm/2016/01/30/Power-Of-Two</guid>
                <pubDate>2016-01-30T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Best Time to Buy and Sell Stock</title>
                <description>&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;

&lt;p&gt;Example
  Given an example [3,2,3,1,2], return 1&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int maxProfit(vector&amp;lt;int&amp;gt; &amp;amp;prices) {
  if (prices.size() == 0) {
    return 0;
  }
  int minValue = INT_MAX, profit = INT_MIN;
  for (int i = 0; i &amp;lt; prices.size(); i++) {
    minValue = min(minValue, prices[i]);
    if (prices[i] - minValue &amp;gt; profit) {
      profit = prices[i] - minValue;
    }
  }
  return profit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/01/29/Best-Time-to-Buy-and-Sell-Stock</link>
                <guid>http://jianwang.info//algorithm/2016/01/29/Best-Time-to-Buy-and-Sell-Stock</guid>
                <pubDate>2016-01-29T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Palindrome Partitioning</title>
                <description>&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;/p&gt;

&lt;p&gt;Return all possible palindrome partitioning of s.&lt;/p&gt;

&lt;p&gt;Example
  Given s = “aab”, return:&lt;/p&gt;

&lt;p&gt;[
    [“aa”,”b”],
    [“a”,”a”,”b”]
  ]&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
  vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result;
  if (s.length() == 0) return result;
  vector&amp;lt;string&amp;gt; list;
  dfs_traverse(result, list, s, 0);
  return result;
}
bool isParlindrome(string s) {
  int left = 0, right = s.length() - 1;
  while (left &amp;lt;= right) {
    if (s[left] != s[right]) {
      break;
    } else {
      left++; right--;
    }
  }
  if (left &amp;lt;= right)
    return false;
  return true;
}
void dfs_traverse(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; &amp;amp;result, vector&amp;lt;string&amp;gt; list, string s, int pos) {
  int len = s.length();
  if (pos == len) {
    result.push_back(list);
  } else {
   for (int i = 1; i &amp;lt;= len - pos; i++) {
     string temp = s.substr(pos, i);
     if (!isParlindrome(temp))
     continue;
     list.push_back(temp);
     dfs_traverse(result, list, s, pos+i);
     list.pop_back();
   }
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/01/24/Palindrome-Partitioning</link>
                <guid>http://jianwang.info//algorithm/2016/01/24/Palindrome-Partitioning</guid>
                <pubDate>2016-01-24T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Top K Frequent Words</title>
                <description>&lt;p&gt;Given a list of words and an integer k, return the top k frequent words in the list.
  You should order the words by the frequency of them in the return list, the most frequent one comes first. If two words has the same frequency, the one with lower alphabetical order come first.
  Do it in O(nlogk) time and O(n) extra space.
Extra points if you can do it in O(n) time with O(k) extra space.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Solution {
 public:
 class resultType {
   public:
   string word;
   int count;
   resultType(string _word, int _count) {
     word = _word;
     count = _count;
  }
  bool operator&amp;lt;(const resultType &amp;amp;oth) const {
    return count &amp;gt; oth.count || (count == oth.count &amp;amp;&amp;amp; word &amp;lt; oth.word);
  }
 };
  vector&amp;lt;string&amp;gt; topKFrequentWords(vector&amp;lt;string&amp;gt;&amp;amp; words, int k) {
  vector&amp;lt;string&amp;gt; result;
  if (words.size() == 0 || k == 0) {
    return result;
  }
  vector&amp;lt;resultType&amp;gt; resultSet;
  map&amp;lt;string, int&amp;gt; map1;
  map&amp;lt;string, int&amp;gt;::iterator iterator1;
  for (int i = 0; i &amp;lt; words.size(); i++) {
   if (map1.find(words[i]) == map1.end())
     map1[words[i]] = 1;
   else
     map1[words[i]] += 1;
  }
  for (iterator1 = map1.begin(); iterator1 != map1.end(); iterator1++) {
    resultSet.push_back(resultType(iterator1-&amp;gt;first, iterator1-&amp;gt;second));
  }
  //sort(resultSet.begin(), resultSet.end());
  sort(resultSet.begin(), resultSet.end(),[&amp;amp;](resultType a, resultType b) {
    return a.count &amp;gt; b.count||(a.count==b.count&amp;amp;&amp;amp;a.word&amp;lt;b.word);});
  for (int i = 0; i &amp;lt; k ; i++) {
    result.push_back(resultSet[i].word);
  }
  return result;
}   };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2016/01/10/Top-K-Frequent-Words</link>
                <guid>http://jianwang.info//algorithm/2016/01/10/Top-K-Frequent-Words</guid>
                <pubDate>2016-01-10T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Closest Number in Sorted Array</title>
                <description>&lt;p&gt;Given a target number and an integer array A sorted in ascending order, find the index i in A such that A[i] is closest to the given target.
Return -1 if there is no element in the array.
Given [1, 2, 3] and target = 2, return 1.
Given [1, 4, 6] and target = 3, return 1.
Given [1, 4, 6] and target = 5, return 1 or 2.
Given [1, 3, 3, 4] and target = 2, return 0 or 1 or 2.
There can be duplicate elements in the array, and we can return any of the indices with same value.
O(logn) time complexity.&lt;/p&gt;

&lt;!--more--&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int closestNumber(vector&amp;lt;int&amp;gt;&amp;amp; A, int target) {
  if (A.size() == 0) {
    return -1;
  } else if (A.size() == 1) {
    return 0;
  }
  int begin = 0;
  int end = A.size() - 1;
  while (begin != end - 1) {
    int mid = (begin + end)/2;
    if (A[mid] == target) {
      return mid;
    } else if (A[mid] &amp;gt; target) {
      end = mid;
    } else {
      begin = mid;
    }
  }
  if (A[begin] == target) {
    return begin;
  } else if (A[end] == target) {
    return end;
  } else if (A[end] - target &amp;gt;= target - A[begin]) {
    return begin;
  } else if (A[end] - target &amp;lt; target - A[begin]) {
    return end;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/14/Closest-Number-in-Sorted-Array</link>
                <guid>http://jianwang.info//algorithm/2015/12/14/Closest-Number-in-Sorted-Array</guid>
                <pubDate>2015-12-14T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Total Occurrence of Target</title>
                <description>&lt;p&gt;Given a target number and an integer array sorted in ascending order. Find the total number of occurrences of target in the array.
Given [1, 3, 3, 4, 5] and target = 3, return 2.
Given [2, 2, 3, 4, 6] and target = 4, return 1.
Given [1, 2, 3, 4, 5] and target = 6, return 0.
Challenge
Time complexity in O(logn)&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
/**
 * @param A an integer array sorted in ascending order
 * @param target an integer
 * @return an integer
 */
int totalOccurrence(vector&amp;lt;int&amp;gt;&amp;amp; A, int target) {
  if (A.size() == 0) {
    return 0;
  } else if (target &amp;lt; A[0]||target &amp;gt; A[A.size()-1]) {
    return 0;
  }
  if (A.size() == 1&amp;amp;&amp;amp;A[0] == target) {
    return 1;
  }
  int begin = 0;
  int end = A.size() - 1;
  while (begin != end -1) {
    int mid = (begin + end)/2;
    if (A[mid] == target) {
      int leftIdx = leftSearch(A, target, begin, mid);
      int rightIdx = rightSearch(A, target, mid, end);
      return rightIdx - leftIdx + 1;
    } else if (A[mid] &amp;gt; target) {
      end = mid;
    } else {
      begin = mid;
    }
  }
  if (A[begin] == target) {
    return 1;
  } else if (A[end] == target) {
    return 1;
  } else {
    return 0;
  }
}
int leftSearch(vector&amp;lt;int&amp;gt;&amp;amp; A, int target, int begin, int end) {
  if (begin == end - 1) {
    if (A[begin] == target) {
      return begin;
    } else {
      return end;
    }
  }
  int mid = (begin + end)/2;
  if (A[mid] ==  target) {
    leftSearch(A, target, begin, mid);
  } else {
    leftSearch(A, target, mid, end);
  }
}
 int rightSearch(vector&amp;lt;int&amp;gt;&amp;amp; A, int target, int begin, int end) {
  if (begin == end - 1) {
    if (A[end] == target) {
      return end;
    } else {
      return begin;
    }
  }
  int mid = (begin + end)/2;
  if (A[mid] ==  target) {
    rightSearch(A, target, mid, end);
  } else {
    rightSearch(A, target, begin, mid);
  }
} };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/13/Total-Occurrence-of-Target</link>
                <guid>http://jianwang.info//algorithm/2015/12/13/Total-Occurrence-of-Target</guid>
                <pubDate>2015-12-13T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Subsets</title>
                <description>&lt;p&gt;Given a set of distinct integers, return all possible subsets.
Example
If S = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
Note
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
Challenge
Can you do it in both recursively and iteratively?&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
  vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; resultSets;
  if (nums.size() == 0) {
   resultSets.push_back(nums);
   return resultSets;
  }
  sort(nums.begin(), nums.end());
  vector&amp;lt;int&amp;gt; list;
  subSetsHelper(resultSets, list, nums, 0);
  return resultSets;
}
void subSetsHelper(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;result, vector&amp;lt;int&amp;gt; &amp;amp;list, vector&amp;lt;int&amp;gt; &amp;amp;nums, int pos) {
  result.push_back(list);
  for (int i = pos; i &amp;lt; nums.size(); i++) {
    list.push_back(nums[i]);
    subSetsHelper(result, list, nums, i+1);
    list.pop_back();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/13/Subsets</link>
                <guid>http://jianwang.info//algorithm/2015/12/13/Subsets</guid>
                <pubDate>2015-12-13T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Subsets II</title>
                <description>&lt;p&gt;Given a list of numbers that may has duplicate numbers, return all possible subsets
Example
If S = [1,2,2], a solution is:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
Note
Each element in a subset must be in non-descending order.
The ordering between two subsets is free.
The solution set must not contain duplicate subsets.
Challenge
Can you do it in both recursively and iteratively?&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt; &amp;amp;S) {
   vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; resultSets;
   vector&amp;lt;int&amp;gt; list;
   if (S.size() == 0) {
    resultSets.push_back(S);
    return resultSets;
   }
    sort(S.begin(), S.end());
    subDivide(resultSets, list, S, 0);
  return resultSets;
}
void subDivide(vector&amp;lt;vector &amp;lt;int&amp;gt;&amp;gt; &amp;amp;result, vector&amp;lt;int&amp;gt; &amp;amp;list, const vector&amp;lt;int&amp;gt; &amp;amp;S, int pos) {
     result.push_back(list);
     for (int i = pos; i &amp;lt; S.size(); i++) {
        if ((i != pos)&amp;amp;&amp;amp;S[i] == S[i-1])
        continue;
        list.push_back(S[i]);
        subDivide(result, list, S, i+1);
        list.pop_back();
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/13/Subsets-II</link>
                <guid>http://jianwang.info//algorithm/2015/12/13/Subsets-II</guid>
                <pubDate>2015-12-13T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Permutations</title>
                <description>&lt;p&gt;Given a list of numbers, return all possible permutations.
Example
For nums = [1,2,3], the permutations are:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
Challenge
Do it without recursion.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permute(vector&amp;lt;int&amp;gt; nums) {
 vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; resultSets;
 vector&amp;lt;int&amp;gt; list;
 if (nums.size() == 0) {
    return resultSets;
 }
 permutation(resultSets, list, nums);
return resultSets;
}
void permutation(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;result, vector&amp;lt;int&amp;gt; &amp;amp;list, vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    if (list.size() == nums.size()) {
      result.push_back(list);
    } else {
        for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (count(list.begin(), list.end(), nums[i]) &amp;gt; 0) {
         continue;
        }
         list.push_back(nums[i]);
         permutation(result, list, nums);
         list.pop_back();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/12/Permutations</link>
                <guid>http://jianwang.info//algorithm/2015/12/12/Permutations</guid>
                <pubDate>2015-12-12T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Permutations II</title>
                <description>&lt;p&gt;Given a list of numbers with duplicate number in it. Find all unique permutations.
Example
For numbers [1,2,2] the unique permutations are:
[
  [1,2,2],
  [2,1,2],
  [2,2,1]
]
Challenge
Using recursion to do it is acceptable. If you can do it without recursion, that would be great!&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permuteUnique(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
  vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; resultSets;
  vector&amp;lt;int&amp;gt; list;
  if (nums.size() == 0) {
    resultSets.push_back(list);
    return resultSets;
  }
  vector&amp;lt;bool&amp;gt; visited(nums.size());
  for_each(visited.begin(), visited.end(), [&amp;amp;](bool x) { x = false;});
  sort(nums.begin(), nums.end());
  permutation(resultSets, list, nums, visited);
  return resultSets;
}
void permutation(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;result, vector&amp;lt;int&amp;gt; &amp;amp;list,
                 vector&amp;lt;int&amp;gt; &amp;amp;nums, vector&amp;lt;bool&amp;gt; &amp;amp;visited) {
    if (list.size() == nums.size()) {
      result.push_back(list);
    } else {
      for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (visited[i] == true||(i != 0&amp;amp;&amp;amp;nums[i] == nums[i-1]&amp;amp;&amp;amp;visited[i-1] == false)) {
          continue;
        }
        visited[i] = true;
        list.push_back(nums[i]);
        permutation(result, list, nums, visited);
        list.pop_back();
        visited[i] = false;
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/12/Permutation-II</link>
                <guid>http://jianwang.info//algorithm/2015/12/12/Permutation-II</guid>
                <pubDate>2015-12-12T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>Min Stack</title>
                <description>&lt;p&gt;Implement a stack with min() function, which will return the smallest number in the stack.
It should support push, pop and min operation all in O(1) cost.
push(1)
pop()   // return 1
push(2)
push(3)
min()   // return 2
push(1)
min()   // return 1&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MinStack { public:   stack&amp;lt;int&amp;gt; mainStack, minStack;
MinStack() {
}
void push(int number) {
  mainStack.push(number);
  if (minStack.empty() || minStack.top() &amp;gt;= number) {
    minStack.push(number);
  }
}
int pop() {
  int top = mainStack.top();
  if (top == minStack.top()) minStack.pop();
  mainStack.pop();
  return top;
}
int min() {
  return minStack.top();
} };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/12/Min-Stack</link>
                <guid>http://jianwang.info//algorithm/2015/12/12/Min-Stack</guid>
                <pubDate>2015-12-12T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>strStr</title>
                <description>&lt;p&gt;For a given source string and a target string, you should output the first index(from 0) of target string in source string.&lt;/p&gt;

&lt;p&gt;If target does not exist in source, just return -1.
  O(n2) is acceptable. Can you implement an O(n) algorithm?
when you meet this problem in a real interview, the interviewer may just want to test your basic implementation ability. But make sure your confirm with the interviewer first.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution { public:
/**
 * Returns a index to the first occurrence of target in source,
 * or -1  if target is not part of source.
 * @param source string to be scanned.
 * @param target string containing the sequence of characters to match.
 */
int strStr(const char *source, const char *target) {
    if (source == NULL||target == NULL) {
    return -1;
    }
    int len_source = strlen(source);
    int len_target = strlen(target);
    for (int i = 0; i &amp;lt; len_source-len_target+1; i++) {
      int j = 0;
      for (j = 0; j &amp;lt; len_target; j++) {
        if (target[j] != source[i+j])
        break;
      }
      if (j == len_target)
      return i;
    }
    return -1;
} };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
</description>
                <link>http://jianwang.info//algorithm/2015/12/11/strStr</link>
                <guid>http://jianwang.info//algorithm/2015/12/11/strStr</guid>
                <pubDate>2015-12-11T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>An amazing book -- Code</title>
                <description>&lt;p&gt;&lt;em&gt;Code&lt;/em&gt; is the most amazing book about computer science that I have ever read which was wrote by Charles Petzold who was the former professor and employee of Microsoft. It uses the most understandable words and examples to tell how each component of a computer works. Each chapter tell a component using a lively story which introduce the princeple of how it was created from the physical aspect. What’s more, it introduces some basic electronic theory which largely improve my understanding about them. Finally, as the reader, I can also learn much history about the development of computer science.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;the-most-important-development-of-computer-science&quot;&gt;The most important development of computer science&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The digital logic is the fundimental theory of morden computer science. Combine with the princeple about telegraph and telephone, the original calculator can be created.
  a) Here are some very important digital logic:
OR 或门, AND 与门, NOR 或非门, NAND 与非门, 缓冲器，反向器，迪摩根定律，XOR异或门, 同或门 
  b) binary
  c) relay 
  d) electronic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trigger makes a computer memorizing
many relays compose of a trigger, 1918年英国射电物理学家 William Henry Eccles和 F.W.Jordan 发明了触发器。构成了ram的基本构造。加上震荡器，寄存器，加法器，计数器，就构成了cpu的雏形。此架构是建立在冯诺伊曼的理论体系上的计算机体系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;晶体管的发明，使得传统的继电器被淘汰，大大的增加了运算速度，节省了cpu成本，石英也成为震荡器的主要材料。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二进制使得加法机的发明
  随后，加减乘除都可以做，其他的复杂的数学运算都是在加法机上做的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文字表示，键盘，鼠标，操作系统，程序语言，互联网，网络，图形化革命&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;未来：物联网，大数据，云计算，可穿戴设备，人工智能，机器学习等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###About the history&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;之前中国在用算盘，罗马，希腊，埃及及印度人也发明了自己的计算方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;霍勒瑞斯参与1890年人口普查，采用纸带打孔形式进行人口统计和计算，到1896年采用射频的方法计算，1915年加入ibm公司。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1935年, Conrad Zuse 发明了继电器计算机，1937年， Howard Aiken改进了版本，来自哈弗大学。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1945年，第一台电子计算机 ENIAC, 冯诺伊曼改进，发明了 EDVAC&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1947年， 晶体管被发明，被誉为20世纪最伟大的发明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1948年，bit概念被提出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1952年， ibm发明了第一台商用计算机 701，研究机构是贝尔实验室，该实验室还发明了unix, c语言。 另外AT&amp;amp;T公司也是1925年从该机构分离出来的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1956年，Shockley 离开bell实验室，在加州南部成立半导体实验室和公司，于是硅谷因此而得名, 第一台晶体管计算机问世。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1971年，微软和摩托罗拉的第一代cpu问世，分别是8080和6800，是现代cpu的始祖。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://jianwang.info//read/2015/07/07/code</link>
                <guid>http://jianwang.info//read/2015/07/07/code</guid>
                <pubDate>2015-07-07T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Why Family Hurt</title>
                <description>&lt;p&gt;Today I finished read the book &lt;em&gt;Why Family Hurt&lt;/em&gt; (为何家会伤人) which is a psychological book about relationship between family members and aspect about how it hurt when treat them improperly. The author, 武志红,  a chinese psychologist, try to tell us practical methods and common rules through vivid cases and great theories . I gained many useful experiences and important recogition about intimacy relationship and child parents relationship, what is more, it  solved a psychological shade of mine and gave me the best answer since my family went wrong as many common Chinese families do.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###Harmful behaviors between lovers&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Guess: if your lover do what you think is wrong, do not guess&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Judge: if you lover complain or anxious about something, don’t judge it by your own view.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Give advise: if your lover ask you some question, do not immediately give advise.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Tip: try to know your lovers feelings first, then accept and understand them. 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t bring your power outside to home&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Tips:divide work from family, family is the place where you should deal with gently and patiently. Keep your family members equal important and give respect to them. Cherish is the main theme of family.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Important theories&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Marital relationship is the core relationship of a family, it has the priority of all family relationships. If so, the family will be very stable. If mother-in-law husband relationship, father son relationship or mother son relationship become priority, everything will go wrong: 1.bad wife mother relationship. 2. Jocasta complex.家庭关系论：夫妻关系是家庭的核心，拥有第一发言权，那么这个家就会稳如磐石。如果公婆丈夫，父子，母子关系凌驾于夫妻关系之上，就会产生问题，1糟糕的婆媳关系 2 严重的恋子情结&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If a mother want her baby grow healthy, she has to company her baby, interact with him/her, watch her baby with joy which is very important for him/her.妈妈与婴儿健康论：若以为妈妈想让你的孩子健康，在他婴幼儿时，多和他互动，看到他，并带着喜悦，是至关重要的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Love and leave is the eternal theme of relationships, they are equally important. Psychologically leave one’s parents is a long period, from childhood to adult, someone cannot leave until death.分离与爱理论：分离与爱同等重要，他们是生命中最重要的两个主题，他们一起作用，让一个人成长，让一个人成为他自己。与家的分离是一个漫长的过程，从幼儿园开始，到长大成人结束，有些人一辈子也完成不了这个过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bert Hellinger Theroy 德国家庭治疗师：伯特.海灵格理论
  男孩在胎儿期和童年早期，主要受母亲的影响。如果他不能突破这种影响，母亲的影响就会充斥着他的心身。他会深深感受到母亲的力量和重要性。在母亲的影响下，他以后很可能成为一个感情骗子和调情高手，但他无法成长为一个珍惜女人并维持长久伴侣关系的男人，无法成为一个好爸爸，也无力维持一段平等的男女关系。他必须放弃那最原始，最亲密的对母亲的依附关系，去接受父亲的影响。
  Tips:男孩要归父亲，女孩要归母亲。即孩子要先向异性父母靠拢，并从这一关系中吸纳异性的力量，体会到自己对异性的吸引力，同时体验到异性对他的吸引力。然后男孩回到男性世界，成为一个男人，女孩回到女性的世界，成为一个女人。只有这样，他们的心理才更健康，而这个世界，才更和谐。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;About Soul
 看不到灵魂的存在，就不知道自己的尊贵。对爱的追求不能以物质的形式而存在，而是认识到灵魂的存在。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###What is wrong with Chinese way of love and family&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;中国式溺爱：限制了自己的自由，一个人为自己而活着的时候才是最有力量的。溺爱是温柔的陷阱。看到孩子真实的存在，发现孩子真实需要，并帮助孩子实现他的需要，这便是真爱。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;成熟的父母不会在第一时间处理孩子的问题，他们会先处理孩子的感受。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;复读中需要解决的不是知识水平问题，而是心理问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果总是一帆风顺，那一个人的思维容易陷入单向度思维，对事情的考虑容易片面；如果一个人总是遭受挫折，那么这个人的思维也容易陷入单向度思维。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中国人有七成至八成的婚姻都是建立在安全感的基础上的，婚姻安全感的最高境界是彼此成了亲人，因为亲人是不会离开你的，想起他就很亲切，但实际上也很少想起他。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于安全感，中国人有单一的物质化界定，比如房子，车子。没有房子就不结婚，所以说，丈母娘推动了中国的房价。爱情还是物质，这种选择题的出发点就是错误的，为什么不能先有爱情然后再有物质条件呢？中国人总是在劝那些在婚姻关系中没有爱情的人，别贪心，不可能得到一切。他们一定不会将爱情放在特别重要的位置，但是真正能够制造安全感的只有爱。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###My thoughts&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I am very happy that most of my life have been going in the comparably right way, However, there are some big mistakes still caused unhealthy problem in my deep soul.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am lucky that I have made a lot of male friends since I attended in middle school which formed my personality especially my sexal preference, and I appreciate my parents send me to a better middle school far away from home which I could totally seperate from family conflict, thus, give me enough time to focus on study rather than feel guilty of being disable to fix family relationships.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have been effected by my mom’s limited recognitions and experiences for a long time since she always anxious about every detail of my life due to her absence and guilty. She always use a wrong way to express her love in order to make herself feel better. So I have never been risky and spirital independent until I  got finacially freedom recently. Self-abasement has convolved me as a ghost for nearly 30 years. I hate ignorance and extreme conservative empiricism.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Today, I am happy that I am a totally independent individule. A new epic is beginning.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://jianwang.info//read/2015/06/24/why-family-hurt</link>
                <guid>http://jianwang.info//read/2015/06/24/why-family-hurt</guid>
                <pubDate>2015-06-24T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>After read Dreaming In Code</title>
                <description>&lt;p&gt;Today I finished read the book &lt;em&gt;Dreaming In Code&lt;/em&gt; which is strongly recommended for software engineers. As expected, the book gave me the unpresedental feeling and recognition of software engineering and management. All the stories told by the book are what I have been experienced when working. I feel regret to read it so late. How do I love it, let me count the ways.Due to what I have read is a Chinese version, excuse me for using Chinese.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###About the history&lt;/p&gt;

&lt;p&gt;1.布鲁克斯(Frederick Brooks)法则：往已延误的项目中补充人力，会让其更加延误。这个理论可谓软件工程的奠基石，因为在软件工业发展之初，软件开发和管理困难重重，软件开发人员的效率几十年以来没有什么进步。但是软件千变万化，软件开发人员遇到的困难也前所未有，他非常有前瞻的提出了一个观点：构建软件系统最难的就是精确设定要做什么东西&lt;/p&gt;

&lt;p&gt;2.Eric S.Raymond 瑞蒙德德观点超越了布鲁克斯，他和同时代的托瓦茨发明了开源系统，所以得出了李纳斯法则：眼球足够多，缺陷无处躲。但是开源项目仍然没有驳倒布鲁克斯，因为开源项目仍然没有解决时间问题，项目延误仍然大量存在。书中给出了大量例证，无论是国家安全局，还是财政局，很多公司几十亿的项目投入上千人，最后仍然无疾而终。但是我们看到大教堂模式的典型代表，linux系统的诞生，让我们看到开源项目的优点。同时也让程序员找到了创作的原动力：乐享即能高效，愉悦是金－－对于创造性工作，玩耍是最经济有效的模式。而同时代，有些前辈提出比较先进的观点：停止设计，开始编码。&lt;/p&gt;

&lt;p&gt;3.随着软件工程的提出，极限编程模式被提出。核心思想是，用力立即去做小软件，不要做大软件。潜台词是如果你一开始就想做大软件，你最后什么都做不出来，但是这会给重用性带来很大的灾难。&lt;/p&gt;

&lt;p&gt;4.凯尔的文章，开始抨击软件，大肆宣扬IT无关紧要和历史终结论。另外还有马克米纳，也鼓吹《软件阴谋论》。激起广泛的社会反响，还成为了畅销书。但是这些都只是历史进程的一点波澜，并不影响软件产业的发展，软件的历史进步作用是不可磨灭的。而历史证明这些理论都是错误的。&lt;/p&gt;

&lt;p&gt;5.大家都希望从本质上消灭代码，uml,mdd,mda软件应运而生，人称意识编程，然而截止到现在什么成果也没有突破，应为根据漏洞抽象法则：在某种程度来说，所有非平常的抽象都有漏洞，抽象总会出错。所以聪明的程序员根本不敢去把程序一层一层抽象网上摞，因为即使抽象到100层，出了问题，仍然要从第0层开始往上找原因，根本无法摆脱计算机底层的东西。就像书里说的：抽象并未真的像人们打算的那样简化我们的生活，漏洞抽象法则意味着，无论何时有人拿出一套本该能提升我们效率的所见即所得新代码抽象工具，你总会听到许多人说“先学会怎么手工做，再用所见即所得工具节省制作时间”。所以抽象节省了工作时间，却没有节省学习的时间，总而言之，尽管我们拥有了越来越高级的编程工具以及越来越好的抽象，但要成为编程高手却越来越难了，这真够扯的。&lt;/p&gt;

&lt;p&gt;6.汉弗里在ibm执行强制进度纪律，取得了成功。基于两个原则：1.计划是强制性的2.从底至上，即根据那些负责按计划执行的程序员的经验和知识来，而不是靠管理者拍脑袋或对市场的期望而来。后来80年代，他加入了卡耐基梅隆大学，创办了软件工程学院，并创建了cmm软件成熟度模型。ps，我报了这个学院，给我出了codility的测试，后来被拒了。。。&lt;/p&gt;

&lt;p&gt;7.新的软件管理办法：mbwa闲逛式管理，也被否定了。因为今天的商业世界中，在对软件项目表现普通不满意表象背后，有着更深层次的焦虑－－只怕问题的根源不在于管理技术的失败，而在于这里工作人的天性。对于许多管理者、甚至对于销售或其他部门的同事而言，程序员根本就属于另一类物种。和他们沟通相当困难、令人丧气。他们对常用的奖励／惩罚刺激手段毫无反应。他们是Geek，他们正是问题所在。&lt;/p&gt;

&lt;p&gt;8.joel test 祖尔测试，要回答12个问题，得分满分就ok，但是大多数公司只能得2分，这里微软和google做的最好。12个问题是：1.你们使用源代码控制么？2你们每步都做构建么？3你们做每日构建么？4你们有缺陷数据库么？5你们会在写新代码之前修复缺陷么？6你们有与当前工作吻合的进度安排么？7你们有规约么？8程序员工作环境安静吗？9你们采用了市面上最好的工具了吗？10你们有测试人员吗？11你们会要求应聘者在面试时写代码吗？12你们做走廊可用性测试吗？&lt;/p&gt;

&lt;p&gt;9.google公司让员工把5分之一的工作时间花在个人项目上。这20%时间的劳动成果可能会变成很酷的新产品，不用担心,google安抚员工说尽管开干，挠自己的痒处。实用最小主义在google用的很好。&lt;/p&gt;

&lt;p&gt;10.罗森伯格法则：软件好做，除非你让她完成新任务。接下来可以推论：只有完成新任务的软件才是值得做的软件。ps听起来是屁话，老练的程序员没有一个愿意去做已经被做烂的软件，比如：日历，课程表，计算机，扫雷，五子棋。&lt;/p&gt;

&lt;p&gt;11.奇点理论：卡兹维尔预言21世纪40年代，软件将会迎来奇点。21世纪20年代，人工智能通过图灵测试，将见证奇点来袭。40年代人类体验将会被根本改变,超越人类想像的人类科技进步将会发生。
11.总结：现今软件批评家们常常抱怨我们还处在这项技术的“修补引擎”阶段。在汽车业发展早期，车辆很有可能在到达目的地之前抛锚，如果你想开到任何地方去，都的先做个业务机修工。同样今天的计算机用户常常也的当业余程序员，学习机器的思维方式，修复在完成工作时遇到的大量问题。最终汽车越来越可靠，控制器件越来越标准化，不必为了驾驶而勉力成为汽修爱好者；可我们却一直在等待，期待按照同样的原则，软件领域中也能出现类似的情形。我支持这个观点，也许有一天我们能达到软件真的变成像水管或汽车一样的地步－－能遵循常例生产，不费心思也能用，而且永不改动。&lt;/p&gt;

&lt;p&gt;###About the experience&lt;/p&gt;

&lt;p&gt;1.在每个编程项目的早期阶段，当团队选择语言和技术，准备切入开发时，关于需求的灵活和程序的不可扩展的两难悖论就已然降临了。对语言和技术的选择，初时无关大局重选亦可，转而便得混凝土般坚如磐石，关系重大。&lt;/p&gt;

&lt;p&gt;2.好的程序员懂得写什么，而卓越的程序员知道改写（并复用）什么。&lt;/p&gt;

&lt;p&gt;3.要想在大型软件中保持高效，你得效忠于它，你要将它印在自己的脑海中。常常做梦也梦到它。&lt;/p&gt;

&lt;p&gt;4.wiki发明者Ward Cunningham：持续跟进代码库中可利用的内容，是最大的信息过载挑战。一直到现在如何做到软件复用，仍然是一个难题。&lt;/p&gt;

&lt;p&gt;###Good books that mentioned&lt;/p&gt;

&lt;p&gt;1.大教堂与集市 《The Cathedral and the Bazar》 Eric S Raymond
此书提出了开源和分享的法则，是开源理论的始祖&lt;/p&gt;

&lt;p&gt;2.计算机编程心理学《The Psychology of Computer Programming》 Gerald Weinberg
第一本，不敢说是最后一本，程序员心理学丛书，号召程序员与他人倾诉，形式越随意越好.&lt;/p&gt;

&lt;p&gt;3.模式语言《A pattern Language》 Christopher Alexande
第一本描写模式语言的书，开创了模式之路&lt;/p&gt;

&lt;p&gt;4.《计算机编程艺术》高纳德
重点推荐，该书从数学基础层面揭示算法的本质，绝对是算法始祖书籍，他还有讲座“theory and Practice”&lt;/p&gt;

&lt;p&gt;5.《圣何塞水星报》 硅谷比较著名的报纸&lt;/p&gt;

&lt;p&gt;6.《硅谷革命》&lt;/p&gt;

</description>
                <link>http://jianwang.info//read/2015/06/23/dreaming-in-code</link>
                <guid>http://jianwang.info//read/2015/06/23/dreaming-in-code</guid>
                <pubDate>2015-06-23T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Visa got approved</title>
                <description>&lt;p&gt;Today is a big day for me, I was approved for my F1 visa. I can’t say I am lucky, because everything that I have done was granted. And based on this thinking, instead of rejoice, I feel so tired that it costed me so long to get everthing right on the way, and this is just the begining of my new choice.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###Milestone&lt;/p&gt;

&lt;p&gt;From now on, I don’t need to take GRE, TOEFL test any more, don’t have to pracitse spoken English with foriegners third time a week, don’t have to worry about my application being rejected, and don’t need to be anxious to borrow money for finacial qualification. Thus, the new epic is beginning, where there is no constrain of culture unity, no discrimination of human value, no critics of individual character development, no judgement of personal behavior, no opacity of leadership election. What I should do is focus on what I would like to do and what I want to be. I call it freedom, happiness, and health which is the original power of human life.&lt;/p&gt;

&lt;p&gt;###What next&lt;/p&gt;

&lt;p&gt;There are four goals in my year of 2015, they are: learn to face, learn to love, learn to cherish, learn to learn. I think I have done facing directly to my departure from my former job, and deal with relationship between me and my colleges. I love all the people appear in my life, who helped me, love me, like me, hate me, hurt me which composed my experience, formlessly developed me. I cherish the relationship with my girl, who is my best love ever in the world. Without her, I cannot reach to the goal which I have already achieved. Without her, I couldn’t be the person who firmly belief there is hope and love in the world. I will give her the best understanding, caring, responsebility, respect, suport and lovein the world. Finally, it is education which rebuild my confidence to study, to human connection, to the objective world, so I will focus on the method of learning to make my world being sustainable to be excellent.&lt;/p&gt;

</description>
                <link>http://jianwang.info//daily/2015/06/01/visa-got-approved</link>
                <guid>http://jianwang.info//daily/2015/06/01/visa-got-approved</guid>
                <pubDate>2015-06-01T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Memo</title>
                <description>&lt;!--more--&gt;

&lt;p&gt;#memo&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	克	333	   s	1.1	Y
	克	7	   s	1.1	Y
	脸	851g	   s	1.1	Y
	腿	851g	   s	1.1	Y
	林克	851g	   s	1.1	Y
	浪	蜡烛	   e	1.1	Y
	浪	speedlearn e	1.1	Y
	易	蜡烛	   e	1.1	Y
	易	蜡烛	   e	1.1	Y
	骨	蜡烛       e	1.1	Y
            骨      851g	   e	1.1	Y
        史学	jwang99	   ed	1.1	Y
        陶	蜡烛浪	   b	1.1	Y
        ..	pay	   mom		Y
        阿	蜡烛浪	   b	1.1	Y
        老爹	37732620   b	1.1	Y
        训	蜡烛g	   b	1.1	Y
        陪跑	蜡烛g	   b	1.1	Y
        余		   mom		Y
     	危		   mom		Y
    web	喆	灯	   eb	1.1	Y
    web	喆	只	   江山		Y
    mb	喆	只	   江山		Y
    web	喆	优	   唯一		Y
    teb	喆		   唯一		Y
    mb	剑	灯	   唯一		Y
    mb	剑	只	   江山		Y
    web	剑	只	   唯一		Y
    web	剑	优	   唯一		Y
    web	剑	灯	   ！！		Y
    web	赵	灯	   唯一		Y
    web	赵	只	   mom		Y
    web	赵	优	   爱1		Y
    web	赵	只	   江山		Y
    web	华	蜡烛易2	   eb	1.1	Y
    web	华	只	   江山		Y
    teb	华		   唯一		Y
    o	急啥	851g	   o	1.1	Y
    o	百云	7q	   o	!!	2010
    o	有裤	131	   o	1.1	Y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>http://jianwang.info//daily/2015/05/15/memo</link>
                <guid>http://jianwang.info//daily/2015/05/15/memo</guid>
                <pubDate>2015-05-15T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Universal Mindmap Cloud Construction</title>
                <description>&lt;p&gt;I have been thinking about a structure for a long time. This structure is shapeless like a piece of cloud which can include anything in the universe. once this structure is constructed, it can solve any problem, even solve problems that will happen in the future. This structure is exist, since it is trememdous, no one think it as a whole.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###Composation&lt;/p&gt;

&lt;p&gt;Firstly, it is composed of inumerous nodes, each node stand for an entity which can be anything in the world. Literally they are nouns. Secondly, these different nodes are connected with lines, these lines are directed, each node points to another, it can be a loop, it can point to each other. Each node can be connected to another. The whole stucture has no boundry.&lt;/p&gt;

&lt;p&gt;###Content
I found everything in the world has connections with each other. For example, geografically, every spot on the earth has features such as location, products, culture, tradition, language, history etc.  Element like “pepper” which belongs to product feature may also belongs to culture in Sichuan province China, thus build a interconnection between different features. Inumerous elements may connected with each other due to logical, literal, commercial, mathematical reasons. Reasons can also be vary from any aspects. Form the macro level, a node can be a field such as economics, math, computer science, outerspace, animals, human beings etc, which can also be connected with each other by the link between there inner connections.&lt;/p&gt;

&lt;p&gt;to be continue…&lt;/p&gt;

</description>
                <link>http://jianwang.info//idea/2015/05/13/universal-structure-cloud-construction</link>
                <guid>http://jianwang.info//idea/2015/05/13/universal-structure-cloud-construction</guid>
                <pubDate>2015-05-13T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Maintenance of github pages</title>
                <description>&lt;p&gt;I am a new learner, content bellow will show some tricks about github pages’ development and maintenance. How to use  git, jekyll, ruby, rails will also be included.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###Recovery
      $ git log –pretty=oneline&lt;/p&gt;

&lt;p&gt;this is to look formal commit&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ git reset --hard 1a410efbd2fdkaldafdkajfdklds059dd55cfe9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;this command is to recover the formal commit using SHA&lt;/p&gt;

&lt;p&gt;For more info, &lt;a href=&quot;http://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D&quot;&gt;click this url&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###Install jekyll
在中国，jekyll所在的网站是被屏蔽的，所以需要用vpn翻墙才能成功执行install jekyll命令x,否则会报超时。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ sudo gem update --system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;update the gem to latest version&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;install jekyll&lt;/p&gt;

&lt;p&gt;if you want to install rails, the command is the same&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ sudo gem install rails
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###jekyll&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ jekyll serve --watch --baseurl &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;this will run the jekyll server, and type the 127.0.0.1:4000 to the url column, you can test or debug the local project&lt;/p&gt;

&lt;p&gt;###Google Custom Search Engine(gcse)
First, you need to submit your website and sitemap to google, otherwise, there would be no result. 
&lt;a href=&quot;https://www.google.com/webmasters/tools/home?hl=en&quot;&gt;click here to submit google webmasters&lt;/a&gt;
Second, customize your google custom search engine API at &lt;a href=&quot;https://cse.google.com/cse/all&quot;&gt;here&lt;/a&gt;
Finally, If you customize your search engine API and use gcse:searchresults-only featrue,pay attention to the “Query Parameter Name” which has to be given your input name. This problem had costed me half a day to settle down. Otherwise, you can not see any response on the result page after submit your search request.&lt;/p&gt;

&lt;p&gt;###Google Analytics
Click &lt;a href=&quot;http://www.google.com/analytics&quot;&gt;Google Analytics&lt;/a&gt; to creat your account.&lt;/p&gt;

&lt;p&gt;A good way to test if it was well set, click your website url and see the Reporting–&amp;gt;Real-Time–&amp;gt;Overview menu if there would be new sessions and new active pages.&lt;/p&gt;

</description>
                <link>http://jianwang.info//trick/2015/05/09/maintenance-of-github-pages</link>
                <guid>http://jianwang.info//trick/2015/05/09/maintenance-of-github-pages</guid>
                <pubDate>2015-05-09T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>After rejected by Cornell Tech</title>
                <description>&lt;!--more--&gt;

&lt;h1 id=&quot;never-say-never&quot;&gt;Never say never&lt;/h1&gt;

&lt;h2 id=&quot;rejected&quot;&gt;Rejected&lt;/h2&gt;
&lt;p&gt;I got a rejection letter from Cornell Tech this morning which ended my four-month waiting. I can’t say I am sad while I can’t say I am happy. I want to say many thing to Cornell Tech which I haven’t had time to say. I have been working very hard on my academic courses and English skill improvement. Although having been taken charge on three software projects at work, I have used most my spare time finish reading an algorithm book, an English writing book, a C programing language book, an algorithm video course (except other courses unrelated to computer science such as Macro Economics) and do language exchange with a English native speaker twice a week in the last three months since I submitted my application of the program. Though I have learned most of the prerequisite courses such as: CS 2800, CS 4410, CS 2110, CS 1130, CS 3410, I would like review them again to make sure I can understand and use them. I believe I can do very well both on the courses and in the job with partners.
   Cornell Tech’s unique master’s program in CS which perfectly meet my requirement, but I failed. GPA seems the main reason though I had 7 years working exprience. I can understand that Cornell would never give admission to a student with GPA lower than 3.0 as a Ivy league member.&lt;/p&gt;

&lt;h2 id=&quot;more-space-to-improve&quot;&gt;More space to improve&lt;/h2&gt;
&lt;p&gt;But everything has two side. If I got the chance to study and cooperate with world-class faculty in Cornell, would I succeed in the future? This result can only prove I don’t have more advantages for educational oppotunities than local American students and high GPA students. I believe this is a good chance for me to improve my acdemic skills and I will work harder on them to get a better oppotunity to career life. Through this application, I found many good videos teach Tech innovation and startups on the Internet which shared by Cornell Tech faculties.such as &lt;a href=&quot;https://twitter.com/Christine_Sneva&quot;&gt;Christine Sneva’s twitter&lt;/a&gt;, &lt;a href=&quot;http://www.usnews.com/news/college-of-tomorrow/articles/2015/04/01/the-next-silicon-valley&quot;&gt;the next silicon valley&lt;/a&gt;, &lt;a href=&quot;http://tech.cornell.edu/news/4-lessons-from-david-tisch-on-how-to-launch-a-successful-company&quot;&gt;how to launch a successful company&lt;/a&gt;. In addtion, I found I am weak in Operating Systems and have a gap in Transition to Object-Oriented Programming. Failure is not the end, there is more space to improve.&lt;/p&gt;

&lt;h2 id=&quot;in-the-future&quot;&gt;In the future&lt;/h2&gt;
&lt;p&gt;It’s the time to make the decision. I think I will choose to study in Stevens Institue of Technology. Focus on big data or  cloud computing, keep on improving algorithm, enhance programing skills and creativity. Life is a long run, learn to love, learn to face, learn to cherish, learn to learn.&lt;/p&gt;
</description>
                <link>http://jianwang.info//daily/2015/05/08/After-rejected-by-Cornell-Tech</link>
                <guid>http://jianwang.info//daily/2015/05/08/After-rejected-by-Cornell-Tech</guid>
                <pubDate>2015-05-08T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>About reading</title>
                <description>&lt;p&gt;我们常常听到一句话：“听君一席话，胜读十年书。”但我们一般的人是没有条件可以成天四处去拜访名师，听圣贤教诲。但我们有一个简单而且便宜的办法，那就是读好书！以下是《鸿观》宋鸿兵老师总结出来的读书心得！。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;##1.0 什么是好书？ 
首先要自成体系，有完备的逻辑架构，同时还得具备血肉丰满，有大量的知识细节，这样的书才有营养，同时，这些书还必须要具有诗性、灵性和神性这三个特点。让人读起来非常过瘾，有节奏感。&lt;/p&gt;

&lt;p&gt;##1.1 好书之上的级别是什么？ 
不仅有自己的体系，不仅文字优美，有大量的细节，同时还能够提出新颖的观点或者说建立在新的逻辑架构之上，而这种逻辑架构是具有突破性的，具有冲击性的。即：脑洞级别的好书。&lt;/p&gt;

&lt;p&gt;##1.2 再之上的级别是什么？ 
脑洞级别的书，同时具有颠覆你三观的震撼力。即：颠覆三观级别的好书。&lt;/p&gt;

&lt;p&gt;##1.3 好书的三个层次 
第一个层次：普通的好书 
第二个层次：脑洞级别的好书 
第三个层次：颠覆性的好书&lt;/p&gt;

&lt;p&gt;##2.0 宋鸿兵推荐7大脑洞级别的好书&lt;/p&gt;

&lt;p&gt;###NO.1 《全球通史》——史学界 A Global History
推荐理由：第一，是一种全新的视角，它是从生产率的提升作为中心的环节，来解读全球的历史，这是它的一大突破；第二，它强调了整个世界历史中各个民族之间的互动，整个全世界各个民族、各个文明发展过程之中，始终处于互动之中，这个是以前的很多历史，所没有的一种视角。所以这本书，可以说具有着强大的冲击力，改变了我们很多对历史的看法。&lt;/p&gt;

&lt;p&gt;###NO.2 《自私的基因》——生物界 The Selfish Gene
推荐理由：看完了《自私的基因》，这本书之后，你会觉得你看问题的深度更深，你会站在分子生物学的层次上，来看万事万物变化的规律，所以说看完之后，让你脑洞大开。&lt;/p&gt;

&lt;p&gt;###NO.3 《枪炮病菌和铁》——人类 Guns, Germs, and Steel
推荐理由：解读了很多以前我们理解不了的事情，特别是文明起源，社会的起源方面，进行了突破性的解释。&lt;/p&gt;

&lt;p&gt;###NO.4 《失控》——互联网 Out Of Control#
推荐理由：也可以说是脑洞打开，像这样的书至少读三遍。但有缺陷，就是讲述的点太多了，不够深入。&lt;/p&gt;

&lt;p&gt;###NO.5 《时间简史》——天体物理 A Brief History Of Time
推荐理由：看完这本书之后，你一定也是对时间的认识，对宇宙的起源，都会产生一个爆炸性的影响。&lt;/p&gt;

&lt;p&gt;###NO.6 《从黎明到衰落》 ——西方文化 From Dawn to Decadence
推荐理由：它回顾了西方，五百年以来的文化现象，从兴起，到现在面临的问题。这本书读完，你对整个西方文化的发展和动态，包括未来的趋势，都会有一个全面的认识。&lt;/p&gt;

&lt;p&gt;###NO.7 《艺术的故事》——艺术史 The Story Of Art
推荐理由：这本书看完之后，你会对艺术，会有一个全新的了解。&lt;/p&gt;

&lt;p&gt;##3.1 读书五神器之一：意志锤 
意志锤：当我们阅读本专业书籍比较轻松，当跨学科跨领域读书会比较困难，知识储备不足，需要意志锤开山劈路。学习中的亮剑精神。 
跨学科跨领域去学习实际上市为了给我们现在的研究，现在的知识体系增加新的刺激，新的灵感。 
开山劈路进入新领域之后，进入读书的第二个阶段&lt;/p&gt;

&lt;p&gt;##3.2 读书五神器之二：逻辑刀 
吸收了大量新的知识，获得了大量的信息之后，怎样去分辨，怎样去取舍，就靠脑子中的逻辑刀。逻辑刀的主要作用就是把获得的大量信息进行分辨，对我们有用的东西深入研究，对我们无用的东西看看即可。 
逻辑刀在分析问题的时候，要把你感兴趣的知识体系一块一块切下来，然后保存起来，这是后面要研究的重点方向，也是深入研究的线索。当你的逻辑刀切下来更专业更细致的东西之后，这些东西会被转入读书的第三个阶段。&lt;/p&gt;

&lt;p&gt;##3.3 读书五神器之三：思考锅 
获取的大量感兴趣的东西在思考锅里进行高压、消化和吸收。 
借助思维导图建立直观的知识体系或知识图。 
无法复述。还是别人的东西。思考锅就是帮助裂解知识，为我所用。&lt;/p&gt;

&lt;p&gt;##3.4 读书五神器之四：模式库 
模式库：就是我们长期在思考过程中所形成的思维方式，这些思维方式最终能够逐渐提炼成模式。 
我们所有认识世界的过程都是在做模式识别。所有伟大的科学发现都是在不同层次发现类似的模式。 
当你经过长时间的跨学科的大量积累，脑中存储的模式会越来越多，而且模式之间能够发生涌现效应，模式和模式之间可以相互刺激，这个时候你的大脑就真的在进化了，当你的模式库里面积累的处理问题的十八般武器越来越多的时候，就进入读书的第五个阶段。&lt;/p&gt;

&lt;p&gt;##3.5 读书五神器之五：智慧流 
在智慧流这个阶段中，你开始有意识的运用调用这些模式，帮你去分析、解决新的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;以下内容来自@宋鸿兵 微博&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;【1】关于读书之一：个人体会是好书有三个境界，极品境界是帮助你建立世界观的书。每个人如何看待自然、社会和生活都需要依赖隐形的认知范式，这就是不同的人看待同样的事物会产生不同印象和观点的原因。理性书籍帮助你意识到范式，感性书籍丰富和滋润着你的范式，堪称经典的伟大著作基本都属于这一层次。&lt;/p&gt;

&lt;p&gt;【2】关于读书之二：好书的第二境界是颠覆已有的世界观。读到这种书你会感觉到强烈震撼，思维爆炸，情感沸腾，一个前所未有的新世界被突然打开。一切充满混沌，但却鲜活生动，以往的范式遭到颠覆，而新的世界观却依稀朦胧。你将充满纠结和渴望，心态处于被倒悬的煎熬，这是重新认识世界、社会和生活的开始。&lt;/p&gt;

&lt;p&gt;【3】关于读书之三：好书的第三境界就是提供丰富的知识与情感内涵。这种书虽然没有形成或改变世界观的高度和烈度，但可以在既有的认知范式之下让你的思想和情感变得更加丰富细腻。读这种书时你会感觉极其美好和充实，笑看云卷云舒。毕竟人的头脑不能总处在革命的状态之下，享受和品味生活才是读书的根本。&lt;/p&gt;

&lt;p&gt;【4】关于读书之四：极品好书如《国富论》将分工的概念提到了世界观的高度，堪称是经济思想史上前所未有的突破，形成了理性人、个人利益最大化与社会福利不矛盾，以及市场总是趋于稳定（即看不见的手）这三大推论的思想基础，大幅降低了人们思考经济问题的平均时间成本。当然，能够颠覆该世界观的好书也有。&lt;/p&gt;

&lt;p&gt;【5】关于读书之五：极品好书《红楼梦》我前后读过17遍，每一遍感受都不同，这就是好书的魔力！开始读的是故事，然后投入的是情感，再往后发现重塑的是人生，最终明白了原来是世界观的成型。优美的文字、细腻的情感、丰富的人生哲学、复杂的社会现象、全景式的时代写真、穿越时空的生命主题，读之永不枯竭！&lt;/p&gt;

&lt;p&gt;【6】关于读书之六：第二境界的好书属于颠覆世界观，如戴孟德的几本名著从根本上冲击了文明起源的观念，他让我处于倒悬的煎熬，文明和历史能够用科学的方法论重新解读吗？至少我看到了朦胧的入口，这让我非常纠结。地理学、植物学、动物学、遗传学、气候学、语言学的跨学科综合，文明起源的逻辑变得无可辩驳&lt;/p&gt;

&lt;p&gt;【7】关于读书之七：《自私的基因》也属于颠覆类名著，人、动植物以及一切生命的利己行为并非出于自身，也不是出于物种的集体，而是基于基因本身的最大繁衍机会，生命体和物种不过是基因的载体而已，这种观念颠覆了自私的基本认知，对社会学、经济学，乃至历史、文化的变迁都产生了极具爆炸力的想像空间。&lt;/p&gt;

&lt;p&gt;【8】关于读书之八：库恩的《科学革命的结构》在高度上超越了波普尔的《猜想与反驳》，范式转变带来的观念革命比证伪原则更深刻，它让我看到经济学存在的理论危机和未来突破的方向。当然，这种书不会是畅销书，但其重大意义远超过畅销书，这类书对读者的思维水平要求较高，而且有点枯燥，一般人会望而却步。&lt;/p&gt;

&lt;p&gt;【9】关于读书之九：巴尔赞的《从黎明到衰落-西方文化500年》堪称天下奇书，作者30多时就准备写西方500年的文化史，一位长者指出他的功力不足以驾驭这个题材，建议作者至少积淀50年再写，巴尔赞真的照办了，他85才开始动笔，写到93，他活到104！如此积淀的作品让中国学者冷汗横流。专注是一切成功的基石！&lt;/p&gt;

&lt;p&gt;【10】关于读书之十：视频学习是21世纪的读书方式，读书需要高度聚集脑力从书中挖掘知识，而视频节目是高手解读的知识直接推送进你的大脑，学习效率不在一个数量级！我的经验是当切入新领域时，首先找最好的视频，8个小时快速了解全貌，然后再找书来深入研究。视频相当于战略轰炸，阅读图书就是步兵白刃战。&lt;/p&gt;

&lt;p&gt;【11】没有比读书更廉价的娱乐，更持久的满足。&lt;/p&gt;

&lt;p&gt;【12】读书的作用果然是：从知识中增长见识！&lt;/p&gt;

&lt;p&gt;【13】立身以立学为先，立学以读书为本。&lt;/p&gt;

&lt;p&gt;【14】读未见书如得良友，见已读书如逢故人。&lt;/p&gt;

&lt;p&gt;【15】犹太人爱书，拿以色列来说，14岁以上的人平均每月读一本书，图书馆1000所，平均4500人就有一个图书馆，仅450万人口的以色列就有100万人办有借书证。人均拥有图书、出版社及读书量上，以色列居世界第一。犹太人的智慧从读书和苦难中得来。智慧，是任何人都抢不走的东西。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;摘自《鸿观》微信公众号及宋鸿兵微博。&lt;/p&gt;
</description>
                <link>http://jianwang.info//read/2015/04/10/about-reading</link>
                <guid>http://jianwang.info//read/2015/04/10/about-reading</guid>
                <pubDate>2015-04-10T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>关于如何设置jekyll的一些格式运用</title>
                <description>&lt;p&gt;怎么说呢，用Jekyll搭建Blog不管被说的多么好用，但终究应该只属于技术宅+爱折腾的群体吧，经常一个Wordpress上的小功能，却要在Jekyll折腾不少时间，比如之前的站内搜索，以及今天的分页以及文章摘要，足足折腾了我一下午，而且最后的解决方案还是不完美，有点小挫败感。&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;增加图片的格式如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184731593&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加行前加一个点符号，直接加 * 即可&lt;/p&gt;

&lt;p&gt;如果要斜体，用两个* 括起来   &lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;站内链接引用的样式 如下
可参考&lt;a href=&quot;/read/2015/04/10/about-reading&quot;&gt;关于阅读&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;回到主题，下面先说下Jekyll分页，这个功能有内置的，但是非常见鬼的，只支持对index.html的分页，你没看错，文件名必须是这个，如果你是用JB的话，把index.md重命名成index.html，然后再继续往下看：&lt;/p&gt;

&lt;p&gt;修改_config.yml文件，增加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 每一页显示的文章数
paginate: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加了上面后，你就可以在index.html页面中，引用paginator这个对象了，记住，只有index.html页面可以用。&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td&gt;变量名&lt;/td&gt;	                &lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.per_page&lt;/td&gt;     &lt;td&gt;每页的文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.posts&lt;/td&gt;        &lt;td&gt;这个分页下所有的文章列表&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_posts&lt;/td&gt;  &lt;td&gt;总文章数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.total_pages&lt;/td&gt;  &lt;td&gt;总页数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.page&lt;/td&gt;         &lt;td&gt;当前页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.previous_page&lt;/td&gt;&lt;td&gt;前一页&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;paginator.next_page&lt;/td&gt;    &lt;td&gt;后一页&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;具体如何使用，参考&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Pagination&quot;&gt;How pagination works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;前面也提到了，这个只支持首页模式，也就是说，你的Blog里有多个文章类目，然后这个是不支持的，所以我称做为不完美的分页。不过我的Blog文章还少，而且我向来是个比较懒的人，等分类下的文章也多了，再来想怎么解决吧。&lt;/p&gt;

&lt;p&gt;下面说说怎么搞文章摘要，如果没有摘要的，列表展示是很头大的。目前有这么几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用内置的truncate或者truncatewords方法，这个好处是内置的，不需要装插件，不需要装插件意味着你可以在托管Github上用，因为Github上很多插件都不支持。但缺点也很明显，对html的标签支持不是很好，如果你是纯文本的Blog，倒也还好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装truncatehtml插件。这个插件首先需要nokogiri，所以你需要在本地安装，安装命令如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install nokogiri
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;然后再安装上述的插件，这个插件的好处就是对解析后的html代码进行控制，但坏处就是，你如果是托管在Github上，那就悲剧了，不能用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面两种方法，都有一个问题，就是对所有文章的摘要提取都是一样的，但是有时候，对于不同的问题，我想显示不同长度的摘要，所以下面隆重祭出第三种方法（其实，也是我在网上找的，版权不归我哈）： 
首先，在你文章里，想要输出摘要的截至地方，打上标签，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ---
 title: some post
 layout: post
 ---

 我有一头小毛驴呀，从来也不骑。

 &amp;lt;!--break--&amp;gt;

 有一天我心血来潮骑它取赶集。  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后用下面的方式截取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  \{\{ post.content  | | split:&#39;&amp;lt;!--break--&amp;gt;&#39; | first \}\}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的方式，就是，你需要在写文章的时候，打一个注释，但是，这个成本，我想，还好吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&quot;&gt;http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://jianwang.info//trick/2014/08/04/paginate_and_excerpt_on_jekyll</link>
                <guid>http://jianwang.info//trick/2014/08/04/paginate_and_excerpt_on_jekyll</guid>
                <pubDate>2014-08-04T00:00:00-07:00</pubDate>
        </item>


</channel>
</rss>
